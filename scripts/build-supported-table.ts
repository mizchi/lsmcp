#!/usr/bin/env node

import { readFileSync, writeFileSync } from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";
import { glob } from "glob";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const rootDir = join(__dirname, "..");

// LSP tools that we support
const ALL_LSP_TOOLS = [
  "get_hover",
  "find_references",
  "get_definitions",
  "get_diagnostics",
  "get_all_diagnostics",
  "rename_symbol",
  "delete_symbol",
  "get_document_symbols",
  // "get_workspace_symbols", // Not implemented yet
  "get_completion",
  "get_signature_help",
  "format_document",
  "get_code_actions",
] as const;

interface AdapterInfo {
  id: string;
  name: string;
  baseLanguage: string;
  description: string;
  unsupported: string[];
}

async function loadAdapters(): Promise<AdapterInfo[]> {
  const adapters: AdapterInfo[] = [];

  // Find all adapter files
  const adapterFiles = await glob("src/adapters/*.ts", { cwd: rootDir });

  for (const file of adapterFiles) {
    if (file.includes("utils.ts") || file.includes("diagnosticProcessors.ts")) {
      continue;
    }

    const content = readFileSync(join(rootDir, file), "utf-8");

    // Extract adapter export with regex
    const adapterMatch = content.match(
      /export const (\w+Adapter): LspAdapter = \{([^}]+(?:\{[^}]*\}[^}]*)*)\}/s,
    );
    if (!adapterMatch) continue;

    try {
      // Extract properties from the adapter object
      const adapterContent = adapterMatch[2];

      const getId = (content: string) => {
        const match = content.match(/id:\s*["']([^"']+)["']/);
        return match ? match[1] : "";
      };

      const getName = (content: string) => {
        const match = content.match(/name:\s*["']([^"']+)["']/);
        return match ? match[1] : "";
      };

      const getBaseLanguage = (content: string) => {
        const match = content.match(/baseLanguage:\s*["']([^"']+)["']/);
        return match ? match[1] : "";
      };

      const getDescription = (content: string) => {
        const match = content.match(/description:\s*["']([^"']+)["']/);
        return match ? match[1] : "";
      };

      const getUnsupported = (content: string): string[] => {
        const match = content.match(/unsupported:\s*\[([^\]]*)\]/s);
        if (!match) return [];

        const unsupportedContent = match[1];
        const items = unsupportedContent.match(/["']([^"']+)["']/g);
        return items ? items.map((item) => item.replace(/["']/g, "")) : [];
      };

      adapters.push({
        id: getId(adapterContent),
        name: getName(adapterContent),
        baseLanguage: getBaseLanguage(adapterContent),
        description: getDescription(adapterContent),
        unsupported: getUnsupported(adapterContent),
      });
    } catch (error) {
      console.warn(`Failed to parse adapter in ${file}:`, error);
    }
  }

  return adapters.sort((a, b) => a.baseLanguage.localeCompare(b.baseLanguage));
}

function generateMarkdownTable(adapters: AdapterInfo[]): string {
  const md: string[] = [];

  md.push(
    "<!-- GENERATED BY scripts/build-supported-table.ts - DO NOT EDIT MANUALLY -->",
  );
  md.push("");
  md.push("# LSP Feature Support Table");
  md.push("");
  md.push("This table shows which LSP features are supported by each adapter.");
  md.push(
    "Generated automatically by `scripts/build-supported-table.ts` - do not edit manually.",
  );
  md.push("");

  // Create header
  md.push("| Adapter | Language | " + ALL_LSP_TOOLS.join(" | ") + " |");
  md.push("| --- | --- | " + ALL_LSP_TOOLS.map(() => "---").join(" | ") + " |");

  // Create rows
  for (const adapter of adapters) {
    const row = [
      `**${adapter.name}**<br/><small>${adapter.description}</small>`,
      adapter.baseLanguage,
    ];

    for (const tool of ALL_LSP_TOOLS) {
      const isSupported = !adapter.unsupported.includes(tool);
      row.push(isSupported ? "✅" : "❌");
    }

    md.push("| " + row.join(" | ") + " |");
  }

  md.push("");
  md.push("## Legend");
  md.push("- ✅ Supported");
  md.push("- ❌ Not supported or not implemented");
  md.push("");
  md.push("## Notes");
  md.push(
    "- Features marked as ❌ will return appropriate error messages when called",
  );
  md.push("- Some adapters may have partial support for certain features");
  md.push(
    "- This table reflects the current implementation and may change as adapters are updated",
  );

  return md.join("\n");
}

async function main() {
  console.log("Building LSP feature support table...");

  const adapters = await loadAdapters();
  console.log(`Found ${adapters.length} adapters`);

  const markdown = generateMarkdownTable(adapters);
  const outputPath = join(rootDir, "LSP_SUPPORTED_TABLE.md");

  writeFileSync(outputPath, markdown);
  console.log(`Generated ${outputPath}`);
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch(console.error);
}
